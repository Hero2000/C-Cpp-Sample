##### C++this指针的作用
一个类有很多对象，这些对象共享成员方法，通过this指针确定是哪个对象调用成员方法
##### C++的new和delete,什么时候用new[]申请，可以用delete释放
如果是自定义类型，调用析构函数，用new[]申请的一定要用delete[]释放
##### C++static关键字的作用
未加static的全局变量和函数在整个项目可见。
- 修饰全局变量，将变量隐藏在当前源文件
- 修饰全局函数，将函数隐藏在当前源文件
- 局部变量，生存期为整个源程序，但是其作用域仍与自动变量相同，而且只初始化一次，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。
##### C++的多态
- 静多态（编译时期的多态），函数重载和模版
- 动多态（运行时期），虚函数，指针/引用指向派生类对象
##### 空间配置器
allocator:该容器使用，主要作用把内存开辟和对象构造分开，把对象析构和内存释放分开
##### vector和list区别
数组和链表的区别
##### map 和 multimap
multimap 允许key重复，map 底层红黑树
##### C++如何防止内存泄露，智能指针详述？
- 内存泄露。分配的堆内存没有释放，再也没有机会释放
//不带引用计数的智能指针
- auto_ptr 
- scoped_ptr 
- unique_ptr
//带引用计数的智能指针
- shared_ptr
- weak_ptr
##### C++如何调用C语言
C和C++生成的符号的方式不同，C和C++之间的API接口是无法直接调用的，C语言的函数声明必须扩在extern "C" {} 中。
```
#ifdef __cplusplus
extern "C" {//C 生成的函数接口，可以在C和C++环境下使用
#endif
int sum(int ,int );
#ifdef __cplusplus
}
#endif
```
##### C++什么时候出现访问越界
- 访问数组越界
- vector容器访问
- string
- array
- 字符串处理，没有添加'\0',导致访问字符串的时候越界了
- 使用类型强转，让一个大类型的指针指向一块小内存，然后指针解引用，访问的内存就越界了
##### C++中累的初始化列表
可以指定对象成员变量的初始化方式，尤其是指定成员对象的构造方式
##### C和C++的区别？
- 引用
- 函数重载
- new/delete malloc/free
- const inline
- 模版
- 类和对象 OOP 设计模式
- STL
- 异常
- 智能指针
- 运算符函数重载
###### C和C++内存分布
实际上没有什么区别，用户空间，内核空间
###### malloc 和 new 的区别
- malloc 按字节开辟内存，失败返回null
- new 底层也是通过malloc开辟内存，但是开始提供初始化,失败返回异常
###### share_ptr 引用计数存在哪里
堆上
###### 迭代器失效问题
迭代器不允许一边读一边修改，当通过迭代器插入一个元素，所有迭代器失效，当通过迭代器删除一个元素，当前删除位置后面所有迭代器都失效
当通过迭代器更新容器元素后，要及时更新迭代器更新，insert/erase都会返回新的位置的迭代器
###### STL哪些是底层由红黑树
set/multiset map/multimap
###### struct和class的区别
- 定义类的时候区别
- 继承时，派生类 class, struct
- class还可以定义模版类型参数
- 。。
####### vector和list
vector是数组一个面向对象的表示，把数组封装起来
####### 编译链接全过程
- 预编译、编译、汇编=》二进制可重定向obj文件 *.o
- 1.合并段，符号解析  2.符号的重定向=》可执行文件
####### 初始化全局变量和未初始化全局变量有什么区别
####### 堆和栈的区别
- 堆内存的大小 > 栈内存
- 堆，低地址到高地址
- 栈，高地址到低地址
####### 构造函数和析构函数可不可以是虚函数
- 构造函数不可以
- 析构函数可以
####### 构造函数和析构函数能不能抛出异常
- 构造函数不能，对象创建失败，就不会调用对象的析构函数
- 析构函数不能，需要保证后面释放资源代码能否执行
####### 宏和内联的区别
- #define是预编译阶段处理，字符串替换，宏没有办法调试
- inline编译阶段处理，通过函数的实参，把函数代码直接展开调用，节省函数的调用开销，debug下inline就和普通函数一样，有标准的函数调用过程
####### 局部变量存在哪里
栈上
####### 拷贝构造函数为什么传引用而不传值
因为拷贝构造函数本身就是用在函数传值的时候使用的。
####### 内联函数和普通函数的区别
核心-函数调用的开销
####### 如何实现一个不可以被继承的类
基类的构造函数私有化
####### 什么是纯虚函数，为什么有纯虚函数，虚函数表放在哪里
一般定义在基类里，主要作用是给派生类保留统一的纯虚函数接口，让派生类进行重写
####### c++中的const和static的区别
const定义的叫常量，编译的方式是把出现常量名字的地方，用常量的值进行替换
const定义常成员方法，普通对象和常对象都可以调用，只能读
//面向过程
const 全局变量，局部变量，形参变量
static 全局变量，局部变量，函数
//面向对象
const 常方法/成员变量
static 静态方法/类变量
####### 四种强制类型转换
####### 虚函数，多态
- 虚函数：一个类如果有虚函数，在编译阶段就产生一张虚函数表，运行时加载到.rodata用指针或引用，调用虚函数，指针访问对象的头四个字节，从中取出虚函数的地址，进行动态绑定调用
- 多态：可以用基类的指针或者引用来接收派生类对象
####### 早绑定和晚绑定
- 早绑定（静态绑定）：普通函数的调用
- 晚绑定（动态绑定）：用指针/引用调用函数的时候都是动态绑定
####### 指针和引用的区别（反汇编分析）
```
int a = 10;
int *p = &a;
int &b = a;
生成的汇编指令相同
```
####### 智能指针交叉引用问题怎么解决
定义对象的时候用强智能指针 share_ptr,而引用对象的时候使用弱智能指针
当通过弱智能指针访问成员对象的时，需要先调用弱智能指针的lock提升方法，提升成强智能指针。
####### 重载的底层实现，虚函数的底层实现
- 重载，函数名+参数
- 虚函数->虚函数表
####### #define和type的区别
```

#define PIN1 int *
typedef (int *) PIN2;

int * a,b;
表示a是指向整型的指针变量，而b是整型变量。

PIN2 a,b;
表示a,b都是指向整型的指针变量。

#define 仅仅是字符串替换
```
####### 在成员函数末尾使用 const 关键字
如果函数不打算更改它们绑定到的对象的状态，那么把他们申明为常量函数就是一种十分良好的“防御性编程”实践。通过这样做，您可以获得来自编译器的额外帮助，它将因此而禁止在函数中添加将更改对象状态的代码。
####### 数组传递给函数
```
void sort(double a[], int size);
void sort(double* a, int size);
在c++中，数组名称实际上是指向它的第一个元素的常量指针。因此这两种形式是等价的。

```
###### 类的复制构造函数，析构函数
```
X(const X&);    //copy constructor
~X();    //destructor
X& operator=(const X&);    //assignment operator
如果没有在类定义中显式声明他们或默认构造函数，编译器将自动为类X创建它们。

```
###### c++ ofstream 的文件打开方式
｜模式｜含义｜
｜-｜-｜
｜in｜打开文件用于读取｜
｜out｜打开文件用于写入｜
｜ate｜打开文件并移到末尾｜
｜app｜打开文件用于追加｜
｜trunc｜若文件已存在，打开文件并截  取流（清除原有数据）｜  
｜binary｜以二进制流方式打开文件｜
####### 帮 C/C++ 程序员彻底了解链接器
```
原翻译表示禁止转载,但是这篇文章太好了,所以厚着脸皮转载过来了.
英文出处:http://www.lurklurk.org/linkers/linkers.html
中文伯乐翻译:http://blog.jobbole.com/96225/?utm_source=tuicool&utm_medium=referral#article-comment
```
